CMPT409 Project
What is an algorithm & is it possible to prove Church Turing Thesis?
Yufeng Shao
Aug 2017

1 Introduction
Computer scientists have been working on algorithms for decades, but there seems to be no definition of an algorithm, which is formal and accepted by all. In our project, we will give a brief introduction to several definitions given by specialists and discuss them in section 2. 
Article[1] by Yiannis Moschovakis proposes to define the basic notions of algorithms in set theory, who also explain his proposals in article[3] that algorithms can be defined with set theory. However, article[2] by Yuri Gurevich does not quite agree, but still admits there is hope to give a rigorous definition of an algorithm, even though the notion of algorithms is expanding[2]. Nachum Dershowitz also has some opinions on this matter, who thinks algorithm is some kind of transition systems[5].  After the discussion on the above opinions, we will present our own thoughts on this subject.
Another important question worth discussing is whether it is possible to prove Church Turing Thesis. Article[4] by Nachum Dershowitz and Yuri Gurevich gives a proof to this thesis based on a certain set of axioms and postulates which most people would agree are evidently true. But whether it is possible to prove the thesis rigorously still remains a question. We will also talk about our perspective after introducing the proof in Article[4].

2 What is an algorithm?
Yiannis Moschovakis¡¯s answer
Moschovakis attempts to define algorithms in set theory. First of all, he lists several statements that he thinks is not precise. For example, he enumerates two ¡°wildly different approaches to the foundations of computer science which treat algorithms as ¡®pre-mathematical¡¯ notions, to be denied rather than defined¡±[1]. The first is thinking algorithms as implementations[1], which is modeled in set theory. The second is regarding algorithms as constructive proofs.
For the first view, he points out that there are at least two serious problems with this approach. ¡°Assume then that we associate with each system E of recursive equations an iterator ¦ÕE, using some fixed ¡°compilation process¡±, and we make the view precise by calling ¦ÕE the algorithm defined by E. Now the first problem with this view is that ¦ÕE is far removed from E and the resulting, rigorous proofs of the important properties of ¦ÕE are complex and only tenuously related to the simple, intuitive arguments.¡±[1] As for the second problem, he points out that, since the compilation is not unique, there is no way to choose a ¡°canonical¡± one, ¡°which makes it very unlikely that we can usefully identify algorithms with computational procedures, or iterators¡±[1].
For the second view, although Moschovakis ¡°doubt seriously that algorithms will ever be eliminated in favor of constructive proofs¡±[1], and points out one problem with it, which is algorithms are able to ¡°support¡± more notions that are not necessarily associated with proofs, he still thinks this view is ¡°worth pursuing¡± because the investigation can improve our ¡°understanding of the important connection between computability and constructivity¡±[1].
Hence comes his own methods of defining an algorithm. He first gives formal definition for iterators, functionals and recursors, based on which he makes the following four proposals.
Proposal I: Implementations are iterators[1]. With the discussion on the example of mergesort and corresponding recursors when compiling the program in different languages, he claims that all the programs compiled are ¡°all implementations of the mergesort algorithm¡±[1], but still, ¡°we cannot say this without an independent notion of the mergesort algorithm¡±[1]. Therefore, it¡¯s not right to claim that algorithms are implementations, as is stated already. In this way, Moschovakis distinguishes the notion of implementations with algorithms, as he is going to propose in his Proposal II.
Proposal II: Algorithms are recursors[1]. According to Moschovakis¡¯s definition of recursor, a recursor ¦Á: X -> W, where X is a poset and W is a set, contains three kinds of information. The first is the domain of ¦Á, the second is the transition mapping of ¦Á and the third is the monotone, partial mapping from X to W. He also gives more detailed explanation of the definition in [3]. Since the mapping is monotone, he concludes from the least fixed point theorem[1] that ¦Á is a recursor on a collection of sets M, if the partial function determined by ¦Á is a functional on M, where a functional by Moschovakis is defined in 6.1[1]. From the discussion, he claims ¡°algorithms are recursors from given primitives¡±[3], because ¡°their parts are direct calls to these primitives and the conditional¡±[3].
Proposal III: To implement means to reduce[1]. The definition by Moschovakis of reduction among recursors[1] is not surprisingly much similar to the definition of reduction among relations. According to Moschovakis, computational models can be represented by recursors[3], and algorithms are recursors, so reduction among recursors implies which computational model is able to implement certain algorithms.
Proposal IV: Algorithms are definable recursors[1]. Moschovakis thinks ¡°there is no corresponding absolute notion of ¡®algorithm¡¯ on the natural numbers¡ªmuch less on arbitrary sets. Algorithms make sense only relative to operations which we wish to admit as immediately given on the relevant sets of data. Any set can be a data set; as for the given operations, we may have partial functions, functionals, or, in the most general case, recursors¡±[1]. And he explains the formal definability of a recursor in 8.2[1], which makes it part of the attempt to defend his proposal.
In summary, Moschovakis introduces the notion of recursors and iterators, ¡°which is a generalization of function specification in Godel¡¯s calculus¡±[2], and he assign semantics to them with the least fixed point theorem[1] mentioned before. Moschovakis aims to ¡°provide a traditional foundation for the theory of algorithms, a development of it within axiomatic set theory in the same way as analysis and probability theory are rigorously developed within set theory on the basis of the set theoretic modeling of their basic notions¡±[14], which adopts recursion as one of the primitive operations. And with all these notions and mathematical and logical derivation, he makes his way through the recursion-based method and gives the definition of algorithms in set theory.

Yuri Gurevich¡¯s answer
Yuri Gurevich first discusses the possibility of defining algorithm rigorously. For this topic, he gives a ¡°yes and no¡± answer. The negative answer is due to the expanding notion of algorithm[2], while the positive answer says there is still hope to rigorously define algorithms, because ¡°Some strata of algorithms have matured enough to support rigorous definitions¡±[2].
As far as Gurevich is concerned, an algorithm is not equivalent to an Turing machine. Although according to Church-Turing Thesis, if we take any computable numerical function there is a Turing machine that computes it, Gurevich thinks there is a lot in the algorithm that a Turing machine will not capture[6]. He comes up with several examples such as idea, level of abstraction, data structures, complexity, etc[6]. He seems to agree more on Kolmogorov that ¡°algorithms compute in steps of bounded complexity¡±[11]. That does not mean algorithms are bounded, but says every step of algorithms has bounded complexity. Gurevich thinks Turing machines are very low level language[6], hence not enough to capture all that in an algorithm. 
Gurevich mentions that back in Turing¡¯s days, algorithms are limited to sequential algorithms[2], in which time Turing ¡°restricted his analysis to ¡®symbolic¡¯ (symbol-pushing, digital) algorithms¡±[2], so his example of gcd function[2] which can be applied to other computable partial functions that are not Turing computable does no harm to Turing¡¯s Thesis.
Moreover, Gurevich discusses the Gandy¡¯s axioms to which he gives his remarks. He thinks very few real-world devices satisfy Gandy¡¯s axioms[2], based on which he points out two problems with Gandy machine: ¡°One problem is the form of the states of Gandy machines: a collection of hereditary finite sets. Another problem is the requirement that state transitions are synchronous¡±[2]. He also points out that Typical parallel or even sequential algorithms do not satisfy Gandy¡¯s axioms[2]. Therefore, he concludes ¡° Gandy¡¯s axioms are really used just to define another parallel computation model¡±[2], and Gandy¡¯s model seems to have no explicit advantages compared to other parallel computational models, according to Gurevich.
In the final part Gurevich makes a discussion on Moschovakis¡¯s definition of algorithm. He applies Moschovakis¡¯s recursor theory to the function exp(xy) and comes up with an insight that ¡°In the case of the exponentiation recursor, the only ¡®computation¡¯ is the process that we described above: start with the nowhere defined exp function, compute exp(x 0 ) for all x > 0, compute x 1 for all x, etc. What should we do in order to compute 32 ? Should we wait until the ¡®computation¡¯ of exp is completed and then apply exp, or should we wait only to the end of stage 3 when all x 2 are computed? The recursor theory says nothing about that.¡±[2] Therefore, he thinks there is no good reason to identify recursors with algorithms. He agrees more on the opinion that ¡°recursion is but one aspect of an algorithm¡±[2]. What¡¯s more, he thinks algorithms have their own abstract level[2], which can range from arbitrary low to arbitrary high, such that the program executing the algorithm does not necessarily addresses all the computational details. Moreover, he finds the recursor approach by Moschovakis does not seem to apply to distribute algorithms, and that approach seems to be limited with monotonicity.
Although Gurevich does not propose a definition of algorithms himself explicitly in [2], he implicitly mentions that abstract state machine is a good direction for finding a result. And we will discuss more on this topic in the final part of this section. In fact, in[6] he says explicitly that an algorithm is any entity satisfying three postulates by Gurevich, which is quite different from the definition given by Moschovakis, though not a rigorous definition. Just to be clear, the three postulates are:
I (sequential time) An algorithm is a state-transition system;
II (abstract states) Logical structures capture salient aspects of states;
III (bounded exploration)The transition relation can be described finitely[13].

Nachum Dershowitz¡¯s answer
Since Nachum Dershowitz worked together with Yuri Gurevich on attempting to prove Church-Turing Thesis, their opinions are similar in some aspects. Dershowitz expresses his idea that algorithms are some kind of transition systems, but the transitions are governed by some finite texts called a program[5]. He considers a computational method as the set of states with a relation or function and then the notion of algorithm can be divorced from the particular representation as a program[4]. Here he refers to states as logical structures that storing information.

Our perspective
We agree more with Yuri Gurevich that an algorithm is a discrete state transition system that we can use logical structures to capture states and the transitions can be described finitely[13]. Moschovakis¡¯s definition of algorithm seems mathematical and thus appealing, but there are a few points we can argue about. Let us explain.
Gurevich comes up with three postulates of sequential algorithms, which are introduced in [13] in detail. He establishes his theory with the approach of abstract state machine, so first of all we need to figure out what a state is by his definition, and what properties states may have. Gurevich thinks ¡°states are full instantaneous descriptions of the algorithm¡±[13], and usually the state of a Turing machine is infinite. We think this is right while the common knowledge thinks Turing machines have finite states. It is true by  Gurevich that a state of a Turing machine reflects more than just its current control, hence the control structure of the Turing machines has only finite states while Turing machines have infinite states. And states can also be viewed as FO structures[13], based on which Gurevich proposes his postulate that all states of a sequential algorithm have the same vocabulary[13]. What¡¯s more, states, or structures, can also be thought of as memories. That¡¯s easy to understand because a state is naturally an encoding of what is going on at the moment, which contains information about the environment, behavior of the object, etc. So what a sequential algorithm actually does is to update from the current state to the next state, meanwhile keep the information it produces or needs in the particular state, hence a discrete state transition system. And since a state can be viewed as a FO structure, we can use such logical items to capture them. The definition seems self-complete in this sense.
While we agree more with Gurevich, yet his definition of algorithm is not so strongly built up. We see in [13] that Gurevich builds his theory of algorithm based on three postulates. Although the postulates seem quite convincing, they are not proved theoretically. Therefore, there may be some unexpected cases which should violate the postulates.
What¡¯s more, Gurevich¡¯s definition of an algorithm is still based on the assumption that the analysis is restricted to sequential algorithms. Gurevich does not provide a definition applicable by all kinds of algorithms which are known today but is limited to part of them. Therefore, it¡¯s valuable for further researches on this topic but now a perfect solution to the problem ¡°What is an algorithm¡±.
As for Moschovakis¡¯s theory, it is constructive and complicated. However, as Gurevich comments, ¡°The analogy in the quotation is clear: concentrate on mathematical properties of algorithms rather than on what kind of entities they are. The analogy makes good sense but it is far from perfect because much more is known about algorithm entities than real-number entities¡±[2]. Moreover, Moschovakis gives semantics to recursors by the least fixed point structures, while there is nothing else[2] with the computational procedure. He does not specify what to do next in order to compute something in an algorithm. And since imperative algorithms can be arbitrarily abstract[2], such that the low level details of an algorithm in Moschovakis¡¯s sense may not be captured by the program executing it. What¡¯s more, Moschovakis does not specify that his definition of an algorithm is restricted to a certain type of algorithm, so we assume it applies to all. But apparently his theorem is not applicable to distributed algorithms, which takes a larger and larger part of practical algorithms. One more to point out, there is a serious limitation in Moschovakis¡¯s theory, that the recursors should be given meaning by a monotone operator, which is not supposed to[2]. Last but not the least, no new examples supporting Moschovakis¡¯s theorem is found since 1984.
 
3 Is it possible to prove Church Turing Thesis?
Proof by Nachum Dershowitz and Yuri Gurevich
Nachum Dershowitz and Yuri Gurevich construct an axiomatization of computation based on abstract state machines, and then they prove Church Turing Thesis under this set of axioms. The axiomatization provided by Dershowitz and Gurevich is as follows:
I. An algorithm determines a sequence of ¡°computational¡± states for each valid input. 
II. The states of a computational sequence are structures. And everything is invariant under isomorphism. 
III. The transitions from state to state in computational sequences are governable by some fixed, finite description. 
IV. Only undeniably computable operations are available in initial states.[4]
As is stated in their proof, ¡°Postulates I¨CIII are called the ¡®Sequential Postulates¡¯ . They axiomatize (deterministic, sequential) algorithms in general, not only those for computable functions; they apply equally to algorithms dealing with complex numbers, say, as to those for integers only. Postulate IV, which will be fleshed out later, ensures that an algorithm is not endowed from the outset with uncomputable oracles, such as infinite precision operations on real numbers, or a solvability decider for Diophantine equations.¡±[4] And they show in [4] that Church Turing Thesis follow from these four postulates, by using the theory of abstract state machine, which Gurevich already proposes in [13], to formalize the set of the above axioms, after which they derive a series of corollaries and finally make it to Church Turing Thesis.

Our thoughts
Formally, Church Turing Thesis is stated as follows: ¡°a function on the natural numbers is computable by a human being following an algorithm, ignoring resource limitations, if and only if it is computable by a Turing machine¡±[16]. First of all, one should provide the definition of computation and computability to make the notion clear, ahead of a proof to Church Turing Thesis. And to cover all that contains in the notion of computability and computation is a difficult task, which we do not see is mentioned in the Dershowitz and Gurevich¡¯s proof. What¡¯s more, since Church Turing Thesis is a thesis, a hypothesis, logically it can only be disproved rather than proved. In Dershowitz and Gurevich¡¯s proof, they say nothing about quantum computation, which is a great limitation. Last but not the least, since they base their proof on the set of axioms they list, which they do not justify in their paper, others need to check whether the set of axioms is true or not, remaining another problem.
What¡¯s more, there is no hurry to prove Church Turing thesis because it can ¡°be viewed as a simplifying assumption or an agreed upon definition enabling us to restrict our attention to a certain class of things on which we can run algorithms¡±[17], and if there is a rigorous proof it should be very difficult since it should come up with a method to enumerate all the models ¡°eligible to simulate algorithms other than Turing machines or lambda calculi and show that their expressive power is not sufficient to cover the intuitive notion of an algorithm¡±[17].

References
1 Yiannis N. Moschovakis, ¡°On founding the theory of algorithms¡±, http://www.math.ucla.edu/~ynm/papers/foundalg.pdf
2 Yuri Gurevich, ¡°What is an algorithm?¡±
3 Yiannis N. Moschovakis, ¡°What is an algorithm?¡±, Mathematics Unlimited, Springer, 2001
4 Nachum Dershowitz & Yuri Gurevich, ¡°A natural axiomatization of computability and proof of Church¡¯s Thesis¡±, Bulletin of Symbolic Logic 14, Sept, 2008
5 Nachum Dershowitz, ¡°The Church-Turing Thesis¡±, https://www.youtube.com/watch?v=dXHPE4MEjZ0
6 Yuri Gurevich, ¡°The Church-Turing Thesis: Story and Recent Progress¡±, https://www.youtube.com/watch?v=7XfA5EhH7Bc
7 A. J. C. Hurkens, Monica McArthur, Yiannis N. Moschovakis, ¡°The Logic of Recursive Equations¡±, The Journal of Symbolic Logic 63, Jun, 1998
8 Yiannis N. Moschovakis, ¡°The Logic of Functional Recursion¡±, Logic and Scientific Methods, Springer, 1997
9 Andreas Blass and Yuri Gurevich, ¡°Algorithms vs. machines¡±, Bull. European
Association for Theoretical Computer Science 77, 2002
10 Andreas Blass and Yuri Gurevich, ¡°Abstract state machines capture parallel
algorithms¡±, ACM Transactions on Computational Logic, 2003
11 Andrei N. Kolmogorov, ¡°On the concept of algorithm¡±, Uspekhi Mat. Nauk, 1953
12 ] Yiannis N. Moschovakis, ¡°Abstract recursion as a foundation of the theory of algorithms¡±, in Computation and Proof theory, Springer, 1984
13 Yuri Gurevich, ¡°Sequential Abstract State Machines Capture Sequential Algorithms¡±, ACM Transactions on Computational Logic 1, 2000
14 Yiannis N. Moschovakis and Vasilis Paschalis, ¡°Elementary algorithms and their implementations¡±, 2008
15 Aaron Sterling , ¡°A mathematical proof of the Church-Turing Thesis?¡±, July, 2011, https://nanoexplanations.wordpress.com/2011/07/04/a-mathematical-proof-of-the-church-turing-thesis/
16 Definition of Church Turing Thesis from Wikipedia, https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis
17 Elnaser Abdelwahab, answer for ¡°Is it possible to prove the Church Turing Thesis¡±, 2017, https://www.quora.com/Is-it-possible-to-prove-the-Church-Turing-thesis

